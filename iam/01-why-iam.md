# 第一层：理解"为什么" (Why) - 深度展开

## 1. 从第一性原理看访问控制

### 1.1 访问控制的本质问题

```
核心问题：如何确保"对的人"对"对的资源"做"对的事"？

这个问题自计算机诞生以来就存在：

┌─────────────────────────────────────────────────────┐
│                                                     │
│    主体 (Subject)  ───────►  资源 (Resource)        │
│         │                        │                 │
│         │    这个动作是否允许？    │                 │
│         └────────────────────────┘                 │
│                                                     │
└─────────────────────────────────────────────────────┘
```

无论技术如何演进，访问控制永远在回答两个问题：

| 问题 | 术语 | 说明 |
|------|------|------|
| 你是谁？ | Authentication (认证/AuthN) | 证明身份 |
| 你能做什么？ | Authorization (授权/AuthZ) | 判断权限 |

### 1.2 一个思想实验

假设你从零开始设计一个系统的访问控制：

```
第一步：只有一个用户，一个资源
─────────────────────────────────────
简单：硬编码检查就行
if user == "admin":
    allow()


第二步：多个用户，多个资源
─────────────────────────────────────
问题：权限组合爆炸

用户: Alice, Bob, Charlie, ...
资源: File1, File2, DB1, API1, ...
操作: Read, Write, Delete, ...

要维护的规则：用户数 × 资源数 × 操作数 = 爆炸


第三步：用户会变动
─────────────────────────────────────
Alice 入职 → 加权限
Bob 离职 → 删权限
Charlie 换组 → 改权限

每次变动都要改代码？不可维护。


第四步：需要审计
─────────────────────────────────────
出了安全事件，谁在什么时候做了什么？
没有记录就无法追溯。
```

你会发现，随着系统规模增长，**权限管理本身就成为一个复杂系统**。

---

## 2. 权限管理的演进史

### 2.1 单机时代：Unix 权限模型

```
1970s：一切从 Unix 开始

┌────────────────────────────────────────────────────────┐
│  $ ls -la                                              │
│  -rwxr-xr--  1  alice  dev  4096  Jan 1  file.txt     │
│   ─┬─ ─┬─ ─┬─                                          │
│    │   │   └── 其他人：只读 (r--)                      │
│    │   └────── 组用户：读和执行 (r-x)                  │
│    └────────── 所有者：读写执行 (rwx)                  │
└────────────────────────────────────────────────────────┘

核心概念：
  - UID/GID：数字标识用户和组
  - rwx：读、写、执行三种权限
  - 每个文件有一个所有者和所属组
```

**Unix 模型的优点：**
- 简单直观
- 实现高效
- 沿用至今（50年了）

**Unix 模型的局限：**
```
问题1：权限粒度粗
───────────────────
只有 r/w/x，无法表达更细的权限
比如"只能追加写入，不能覆盖"

问题2：只有三个角色槽位
───────────────────
owner / group / others
想要更复杂的分组？做不到

问题3：只能管本机
───────────────────
Alice 在机器 A 上有账号
Alice 想访问机器 B？
→ 要在机器 B 上再创建一个账号
→ 密码同步？权限同步？噩梦
```

### 2.2 网络时代：目录服务 (LDAP/AD)

```
1990s：企业有了上百台服务器，问题来了

┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐
│ Server1 │ │ Server2 │ │ Server3 │ │ Server4 │
│ alice   │ │ alice   │ │ alice   │ │ alice   │
│ bob     │ │ bob     │ │ bob     │ │ bob     │
└─────────┘ └─────────┘ └─────────┘ └─────────┘

每台机器维护一份用户列表？
Alice 改密码要改 100 次？
Alice 离职要删 100 个账号？

解决方案：中心化目录服务

           ┌──────────────────┐
           │   LDAP / AD      │
           │  (统一用户目录)   │
           └──────────────────┘
                    │
        ┌───────────┼───────────┐
        ▼           ▼           ▼
   ┌─────────┐ ┌─────────┐ ┌─────────┐
   │ Server1 │ │ Server2 │ │ Server3 │
   │  查询    │ │  查询    │ │  查询    │
   └─────────┘ └─────────┘ └─────────┘
```

**目录服务带来的进步：**
- 单点管理用户和组
- 入职：加一次
- 离职：删一次
- 改密码：改一次

**但仍有局限：**
```
问题1：仍然是"用户-组-资源"的简单模型
───────────────────
无法表达复杂的权限规则
比如"只有在办公网络才能访问"

问题2：边界假设
───────────────────
假设存在一个"内网"
内网 = 信任，外网 = 不信任
这个假设在云时代崩塌了

问题3：主要解决人的身份
───────────────────
程序/服务的身份呢？
Service A 要访问 Service B，用谁的身份？
```

### 2.3 云时代：IAM 的诞生

```
2006：AWS 推出 S3，开启云时代
2010：AWS IAM 正式发布

云的本质变化：

┌────────────────────────────────────────────────────────┐
│                     Before Cloud                       │
│                                                        │
│  物理边界存在     "内网 = 信任"     服务器数量有限      │
│  运维人员管理      权限变化缓慢      人是主要操作者      │
└────────────────────────────────────────────────────────┘
                          │
                          ▼
┌────────────────────────────────────────────────────────┐
│                     After Cloud                        │
│                                                        │
│  物理边界消失     零信任成为必须     资源数量爆炸       │
│  API 驱动一切     权限变化频繁      程序是主要操作者    │
└────────────────────────────────────────────────────────┘
```

**云时代面临的新挑战：**

```
挑战1：资源数量爆炸
───────────────────
不再是几十台服务器，而是：
- 数千个 S3 Bucket
- 数百个数据库实例
- 数千个 Lambda 函数
- 数万个 API 端点
- 无数个 Container/Pod

权限规则如何管理？


挑战2：边界消失
───────────────────
传统：防火墙内 = 安全
     防火墙外 = 危险

云时代：
- 员工在家办公
- 合作伙伴要访问你的 API
- 你的服务要访问第三方服务
- 多云架构跨云厂商

哪里是边界？没有边界。


挑战3：机器身份
───────────────────
以前：人登录服务器执行命令
现在：CI/CD 自动部署
      Lambda 自动执行
      Pod 自动扩缩容

这些"非人类"如何获得权限？
不能给它们密码让它们"登录"


挑战4：精细化控制需求
───────────────────
不再是简单的 rwx，而是：
- 只能读取特定前缀的 S3 对象
- 只能在特定时间段访问
- 只能从特定 IP 访问
- 只能访问带有特定标签的资源
- 必须启用 MFA 才能删除


挑战5：跨账号/跨组织
───────────────────
多账号架构：生产/测试/开发 分账号
合作伙伴需要有限访问你的资源
外包团队临时访问

如何安全地"借出"权限？
```

---

## 3. IAM 的核心设计思想

### 3.1 Everything is API

```
云的本质：一切操作都是 API 调用

传统方式：
  $ ssh server
  $ vim /etc/nginx/nginx.conf
  $ systemctl restart nginx

云时代：
  POST /ec2/instances         ← 创建实例
  PUT /s3/bucket/object      ← 上传对象
  DELETE /rds/instances/xxx  ← 删除数据库

每个操作 = 一个 API 调用 = 一个可以被控制的权限点
```

这就是为什么 IAM 策略是这样的结构：

```json
{
  "Effect": "Allow",
  "Action": "s3:GetObject",      ← 哪个 API
  "Resource": "arn:aws:s3:::my-bucket/*"  ← 哪些资源
}
```

### 3.2 策略的数学本质

IAM 策略本质上是一个 **布尔函数**：

```
authorize(principal, action, resource, context) → Allow | Deny

输入：
  - principal: 谁在请求
  - action: 请求什么操作
  - resource: 对什么资源
  - context: 请求的上下文（时间、IP、是否 MFA 等）

输出：
  - Allow（允许）
  - Deny（拒绝）
```

这个函数需要满足一些特性：

```
特性1：默认拒绝 (Deny by Default)
─────────────────────────────────
没有明确允许 = 拒绝
安全性优先于便利性

特性2：显式拒绝优先 (Explicit Deny Wins)
─────────────────────────────────
一条规则说 Allow，另一条说 Deny → 结果是 Deny
宁可误杀，不可漏放

特性3：策略可组合 (Composable)
─────────────────────────────────
多个策略可以叠加
最终权限 = 所有策略的综合效果
```

### 3.3 身份的抽象层次

```
IAM 对身份做了层次化抽象：

┌─────────────────────────────────────────────────────────┐
│                     Principal Types                     │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Root Account ─────── 最高权限，尽量不使用              │
│       │                                                 │
│       ├── IAM User ─── 人类用户，有长期凭证             │
│       │                                                 │
│       ├── IAM Role ─── 可被"假扮"的身份，临时凭证      │
│       │      │                                          │
│       │      ├── Service Role (被服务使用)              │
│       │      ├── Cross-account Role (跨账号)            │
│       │      └── Federated Role (联邦身份)              │
│       │                                                 │
│       └── IAM Group ── 用户的集合，方便批量管理         │
│                                                         │
└─────────────────────────────────────────────────────────┘

关键洞见：
  IAM User = 身份 + 长期凭证
  IAM Role = 身份 + 信任关系 + 临时凭证

  Role 更安全，因为：
  - 没有长期密码/密钥可泄露
  - 每次使用都要证明"我有资格假扮你"
  - 凭证自动过期
```

### 3.4 为什么需要 Assume Role？

```
问题场景：Service A 需要访问 Service B 的资源

方案1：共享凭证 ❌
────────────────
把 B 的 Access Key 给 A
问题：
  - Key 泄露就完了
  - 无法审计是 A 用的还是被盗用的
  - 无法给 A 最小权限

方案2：Assume Role ✓
────────────────
B 创建一个 Role，允许 A 假扮
A 需要时申请临时凭证

┌───────────────┐                ┌───────────────┐
│   Service A   │                │   Service B   │
│               │                │               │
│  "我是 A，    │                │   Role-for-A  │
│   我想变成    │───────────────►│   Trust: A    │
│   Role-for-A" │                │   Perm: ...   │
│               │                │               │
│               │◄───────────────│               │
│  收到临时凭证  │   返回 Token    │               │
│  (1小时有效)  │                │               │
└───────────────┘                └───────────────┘

优势：
  - 无长期凭证传输
  - 精确控制 A 能做什么
  - 可审计（谁在什么时候 assume 了）
  - 自动过期
```

---

## 4. 云 IAM 解决了什么问题

### 4.1 问题与解决方案对照

| 传统问题 | IAM 解决方案 |
|----------|-------------|
| 用户分散在各个系统 | 统一身份管理 |
| 权限粒度粗 (rwx) | 细粒度 API 级别控制 |
| 无法表达条件 | Condition 支持复杂条件 |
| 机器没有身份 | IAM Role + 工作负载身份 |
| 凭证长期有效易泄露 | STS 临时凭证 |
| 跨系统访问困难 | Assume Role + Federation |
| 审计追踪困难 | CloudTrail 等审计日志 |

### 4.2 一个实际场景

```
场景：电商网站的权限设计

┌─────────────────────────────────────────────────────────┐
│                      AWS Account                        │
│                                                         │
│  ┌─────────────┐   ┌─────────────┐   ┌─────────────┐  │
│  │ 开发者      │   │ 运维       │   │ 财务        │   │
│  │ IAM User    │   │ IAM User   │   │ IAM User    │   │
│  │             │   │            │   │             │   │
│  │ 权限：      │   │ 权限：     │   │ 权限：       │  │
│  │ - 读代码仓库│   │ - 管理EC2  │   │ - 看账单     │  │
│  │ - 写测试环境│   │ - 管理RDS  │   │ - 设预算     │  │
│  │ - 读生产日志│   │ - CloudWatch│  │              │   │
│  └─────────────┘   └─────────────┘   └─────────────┘  │
│                                                         │
│  ┌─────────────┐   ┌─────────────┐   ┌─────────────┐  │
│  │ Web Service │   │ Order Svc  │   │ CI/CD       │   │
│  │ IAM Role    │   │ IAM Role   │   │ IAM Role    │   │
│  │             │   │            │   │             │   │
│  │ 权限：      │   │ 权限：     │   │ 权限：       │  │
│  │ - 读商品图片│   │ - 读写订单DB│  │ - 部署到ECS  │  │
│  │ - 调用支付API│  │ - 发送通知  │  │ - 更新Lambda │  │
│  │ - 写用户日志│   │            │   │ - 读取Secret │  │
│  └─────────────┘   └─────────────┘   └─────────────┘  │
│                                                         │
└─────────────────────────────────────────────────────────┘

每个身份只有它需要的权限，不多一分。
```

---

## 5. 总结：第一性原理的三个层次

```
Layer 0: 为什么需要访问控制？
         → 资源有价值，必须保护
         → 多人协作，必须区分权限

Layer 1: 为什么传统方案不够用？
         → 规模爆炸：资源数、用户数、权限组合
         → 边界消失：没有内外网之分
         → 机器身份：程序也需要权限

Layer 2: 为什么 IAM 这样设计？
         → API 化：一切操作都是 API，可精细控制
         → 策略抽象：Principal/Action/Resource/Condition
         → 临时凭证：Assume Role，降低泄露风险
         → 可组合：策略叠加，灵活管理
```

> **核心洞见：IAM 不是在"管理用户"，而是在回答每一个 API 请求"这个操作是否被允许"。理解这一点，就理解了云安全的基石。**

---

## 思考题

1. 为什么说"默认拒绝"比"默认允许"更安全？
2. 如果没有 Assume Role，你会怎么实现跨账号访问？有什么问题？
3. 为什么机器身份比人类身份更需要临时凭证？
