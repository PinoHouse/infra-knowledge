# 第三层：身份与凭证 (Identity & Credentials) - 深度展开

## 1. 从第一性原理看身份

### 1.1 身份的本质问题

```
在访问控制中，"身份"要回答一个根本问题：

┌─────────────────────────────────────────────────────────┐
│                                                         │
│   如何证明"你是你"？                                    │
│                                                         │
│   现实世界              数字世界                        │
│   ──────────           ──────────                       │
│   身份证               用户名/密码                      │
│   护照                 Access Key                      │
│   指纹                 Token                           │
│   人脸                 Certificate                     │
│                                                         │
│   共同点：需要一个"凭证"来证明身份                      │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 1.2 身份的两个层面

```
身份 = 标识符 + 凭证

┌─────────────────────────────────────────────────────────┐
│                                                         │
│   标识符 (Identifier)                                  │
│   ────────────────                                      │
│   "你叫什么名字"                                        │
│   例：alice@example.com, arn:aws:iam::123:user/alice   │
│                                                         │
│   凭证 (Credential)                                    │
│   ────────────────                                      │
│   "你怎么证明你就是那个名字"                             │
│   例：密码, Access Key, Token, Certificate             │
│                                                         │
└─────────────────────────────────────────────────────────┘

标识符只是名字，凭证才是证明。
没有凭证的标识符没有意义。
```

---

## 2. 两类主体：人 vs 机器

### 2.1 人类用户 (Human Users)

```
特征：
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  交互方式：控制台登录、CLI 命令                         │
│  认证方式：用户名密码、MFA、SSO                         │
│  使用模式：间歇性、非持续                               │
│  安全考量：密码泄露、钓鱼攻击、社会工程                  │
│                                                         │
└─────────────────────────────────────────────────────────┘

典型场景：
  - 开发者通过控制台管理资源
  - 运维人员通过 CLI 执行操作
  - 管理员配置权限和策略
```

**人类用户的认证流程：**

```
┌──────────┐    用户名/密码     ┌──────────────┐
│  浏览器   │ ─────────────────► │  AWS 控制台  │
│          │                    │              │
│          │ ◄───────────────── │  验证成功    │
│          │    Session Cookie  │              │
└──────────┘                    └──────────────┘
      │
      │  后续请求携带 Cookie
      ▼
┌──────────────────────────────────────────────┐
│                 无需再次输入密码              │
│           (Session 有过期时间)               │
└──────────────────────────────────────────────┘
```

### 2.2 机器身份 (Machine Identity)

```
特征：
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  交互方式：API 调用、SDK                                │
│  认证方式：Access Key、Role、Token                      │
│  使用模式：持续性、自动化                               │
│  安全考量：凭证泄露、权限过大、无人监督                  │
│                                                         │
└─────────────────────────────────────────────────────────┘

典型场景：
  - EC2 实例访问 S3
  - Lambda 函数调用 DynamoDB
  - CI/CD 流水线部署应用
  - Kubernetes Pod 访问云资源
```

**为什么机器身份更复杂？**

```
人类用户                      机器身份
──────────                    ──────────
数量有限（几十到几百）         数量巨大（可能上万）
可以记住密码                  不能"记住"，需要存储凭证
可以做 MFA                    无法做传统 MFA
有安全意识                    代码逻辑决定行为
登录失败会发现                凭证泄露可能长期不知道
```

### 2.3 为什么要区分？

```
不同类型的身份需要不同的安全策略：

┌─────────────────────────────────────────────────────────┐
│                     人类用户                            │
├─────────────────────────────────────────────────────────┤
│  ✓ 使用 SSO/Federation，避免创建 IAM User              │
│  ✓ 强制 MFA                                            │
│  ✓ 定期轮换密码                                        │
│  ✓ 按职能分配权限                                       │
│  ✓ 设置登录告警                                        │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│                     机器身份                            │
├─────────────────────────────────────────────────────────┤
│  ✓ 优先使用 IAM Role，而非 Access Key                  │
│  ✓ 最小权限原则更严格                                   │
│  ✓ 使用临时凭证 (STS)                                  │
│  ✓ 绑定到特定工作负载                                   │
│  ✓ 监控异常 API 调用模式                                │
└─────────────────────────────────────────────────────────┘
```

---

## 3. 凭证的演进

### 3.1 长期凭证 (Long-term Credentials)

```
类型1：密码 (Password)
─────────────────────
用于：控制台登录
特点：人类可记忆，但容易被猜测/泄露

类型2：Access Key (AK/SK)
─────────────────────
Access Key ID:     AKIAIOSFODNN7EXAMPLE
Secret Access Key: wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY

用于：API 调用、CLI、SDK
特点：一对字符串，用于签名请求
```

**Access Key 的工作原理：**

```
请求签名过程：

┌──────────────────────────────────────────────────────────┐
│                                                          │
│  1. 构造请求                                             │
│     GET /my-bucket/file.txt                             │
│     Host: s3.amazonaws.com                              │
│     Date: Mon, 15 Jan 2024 10:30:00 GMT                │
│                                                          │
│  2. 用 Secret Key 对请求进行 HMAC-SHA256 签名            │
│     StringToSign = Method + Path + Headers + ...        │
│     Signature = HMAC-SHA256(SecretKey, StringToSign)    │
│                                                          │
│  3. 将签名附加到请求头                                   │
│     Authorization: AWS4-HMAC-SHA256                     │
│       Credential=AKIAIOSFODNN7EXAMPLE/20240115/...      │
│       Signature=fe5f80f77d5fa3beca038a248ff027d0...     │
│                                                          │
│  4. AWS 用同样的 Secret Key 验证签名                     │
│                                                          │
└──────────────────────────────────────────────────────────┘

关键点：Secret Key 从不在网络上传输，只用于签名
```

**长期凭证的问题：**

```
问题1：泄露风险
───────────────
┌─────────────────────────────────────────────────────────┐
│  真实案例：Access Key 硬编码在代码中                     │
│                                                         │
│  config.py:                                            │
│    AWS_ACCESS_KEY = "AKIAIOSFODNN7EXAMPLE"  ← 提交到   │
│    AWS_SECRET_KEY = "wJalrXUtnFE..."         GitHub   │
│                                                         │
│  后果：                                                 │
│  - 机器人在几分钟内扫描到                               │
│  - 被用于挖矿/攻击                                      │
│  - 产生巨额账单                                         │
└─────────────────────────────────────────────────────────┘


问题2：难以轮换
───────────────
┌─────────────────────────────────────────────────────────┐
│  Key 嵌入在多个地方：                                   │
│                                                         │
│  - 服务器配置文件                                       │
│  - CI/CD 环境变量                                       │
│  - 第三方服务配置                                       │
│  - 开发者本地 ~/.aws/credentials                       │
│                                                         │
│  要轮换？要同时更新所有这些地方，还不能有遗漏           │
└─────────────────────────────────────────────────────────┘


问题3：权限过宽
───────────────
┌─────────────────────────────────────────────────────────┐
│  一个 Key 往往被多个场景复用：                          │
│                                                         │
│  同一个 Key 用于：                                      │
│  - 开发测试                                             │
│  - CI/CD 部署                                           │
│  - 生产服务调用                                         │
│                                                         │
│  结果：Key 拥有所有这些场景的权限总和                   │
│  违反最小权限原则                                       │
└─────────────────────────────────────────────────────────┘


问题4：难以追溯
───────────────
┌─────────────────────────────────────────────────────────┐
│  CloudTrail 日志显示：                                  │
│                                                         │
│  "userIdentity": {                                     │
│    "accessKeyId": "AKIAIOSFODNN7EXAMPLE"              │
│  }                                                      │
│                                                         │
│  问题：这个 Key 被谁用了？从哪里调用的？                │
│  如果 Key 被多人/多系统共享，无法确定                   │
└─────────────────────────────────────────────────────────┘
```

### 3.2 临时凭证 (Temporary Credentials)

```
通过 AWS STS (Security Token Service) 获取

临时凭证包含三部分：
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  AccessKeyId:     ASIAIOSFODNN7EXAMPLE                 │
│                   ↑ 注意开头是 ASIA，不是 AKIA         │
│                                                         │
│  SecretAccessKey: wJalrXUtnFEMI/K7MDENG/...            │
│                                                         │
│  SessionToken:    FwoGZXIvYXdzEBY...很长一串...        │
│                   ↑ 临时凭证特有                        │
│                                                         │
│  Expiration:      2024-01-15T11:30:00Z                 │
│                   ↑ 过期时间，通常 15 分钟到 12 小时    │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

**临时凭证的获取方式：**

```
方式1：AssumeRole
─────────────────
用已有身份假扮一个 Role，获取该 Role 的临时凭证

aws sts assume-role \
  --role-arn arn:aws:iam::123456789012:role/MyRole \
  --role-session-name MySession


方式2：AssumeRoleWithWebIdentity
─────────────────
用外部 OIDC Token（如 GitHub、Google）换取临时凭证

aws sts assume-role-with-web-identity \
  --role-arn arn:aws:iam::123456789012:role/MyRole \
  --web-identity-token $OIDC_TOKEN \
  --role-session-name GitHubActions


方式3：GetSessionToken
─────────────────
用长期凭证换取临时凭证（通常用于 MFA）

aws sts get-session-token \
  --serial-number arn:aws:iam::123456789012:mfa/user \
  --token-code 123456


方式4：Instance Metadata (EC2/ECS/Lambda)
─────────────────
运行时自动从元数据服务获取，无需任何配置

curl http://169.254.169.254/latest/meta-data/iam/security-credentials/MyRole
```

### 3.3 为什么临时凭证更安全？

```
优势1：自动过期
──────────────
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  长期凭证                   临时凭证                    │
│  ──────────                 ──────────                  │
│  泄露了                     泄露了                      │
│     ↓                          ↓                        │
│  永久有效                   几小时后过期                │
│  必须手动吊销               自动失效                    │
│                                                         │
│  攻击窗口：无限             攻击窗口：有限              │
│                                                         │
└─────────────────────────────────────────────────────────┘


优势2：可追溯来源
──────────────
┌─────────────────────────────────────────────────────────┐
│  临时凭证记录了"谁、为什么"获取的：                     │
│                                                         │
│  CloudTrail 日志：                                      │
│  {                                                      │
│    "eventName": "AssumeRole",                          │
│    "requestParameters": {                              │
│      "roleArn": "arn:aws:iam::123:role/DeployRole",   │
│      "roleSessionName": "github-actions-main-abc123"  │
│    },                                                   │
│    "sourceIPAddress": "140.82.112.x"  // GitHub IP    │
│  }                                                      │
│                                                         │
│  可以精确知道是哪个 GitHub workflow 触发的              │
└─────────────────────────────────────────────────────────┘


优势3：无需存储
──────────────
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  长期凭证                   临时凭证                    │
│  ──────────                 ──────────                  │
│  必须存储在某处             运行时动态获取              │
│  - 配置文件                 - EC2 从 IMDS 获取          │
│  - 环境变量                 - Lambda 自动注入           │
│  - Secret Manager          - K8s 从 IRSA 获取          │
│                                                         │
│  存储就有泄露风险           没有存储，无从泄露          │
│                                                         │
└─────────────────────────────────────────────────────────┘


优势4：精确权限
──────────────
┌─────────────────────────────────────────────────────────┐
│  每次 AssumeRole 可以附加 Session Policy：              │
│                                                         │
│  Role 权限：s3:*                                       │
│  Session Policy：只允许 s3:GetObject                   │
│  最终权限：s3:GetObject                                │
│                                                         │
│  同一个 Role，不同任务可以获取不同的最小权限            │
└─────────────────────────────────────────────────────────┘
```

---

## 4. IAM User vs IAM Role

### 4.1 核心区别

```
┌────────────────────────────────────────────────────────────────┐
│                        IAM User                                │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  本质：一个"人"的数字身份                                      │
│                                                                │
│  特点：                                                        │
│  - 有长期凭证（密码、Access Key）                              │
│  - 直接附加权限策略                                            │
│  - 代表一个具体的人或服务                                       │
│  - 创建后一直存在，直到被删除                                   │
│                                                                │
│  适用场景：                                                    │
│  - 需要控制台登录的人类用户                                     │
│  - 需要长期 Access Key 的特殊场景（尽量避免）                   │
│                                                                │
└────────────────────────────────────────────────────────────────┘


┌────────────────────────────────────────────────────────────────┐
│                        IAM Role                                │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  本质：一组权限 + 信任关系，可以被"假扮"                       │
│                                                                │
│  特点：                                                        │
│  - 没有长期凭证                                                │
│  - 定义"谁可以假扮我"（Trust Policy）                          │
│  - 定义"假扮后能做什么"（Permission Policy）                   │
│  - 被假扮时生成临时凭证                                        │
│                                                                │
│  适用场景：                                                    │
│  - EC2/Lambda/ECS 等服务的权限                                 │
│  - 跨账号访问                                                  │
│  - 联邦身份（OIDC/SAML）                                       │
│  - 任何需要临时凭证的场景                                       │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

### 4.2 Role 的结构

```
一个 IAM Role 由两部分组成：

┌─────────────────────────────────────────────────────────┐
│                     IAM Role                            │
├──────────────────────────┬──────────────────────────────┤
│    Trust Policy          │    Permission Policy         │
│    (信任策略)             │    (权限策略)                │
├──────────────────────────┼──────────────────────────────┤
│                          │                              │
│  回答：谁能 Assume 我？   │  回答：Assume 后能做什么？   │
│                          │                              │
│  {                       │  {                           │
│    "Principal": {        │    "Effect": "Allow",        │
│      "Service":          │    "Action": [               │
│        "ec2.amazonaws.   │      "s3:GetObject",         │
│          com"            │      "s3:PutObject"          │
│    },                    │    ],                        │
│    "Action":             │    "Resource":               │
│      "sts:AssumeRole"    │      "arn:aws:s3:::         │
│  }                       │        my-bucket/*"          │
│                          │  }                           │
│                          │                              │
└──────────────────────────┴──────────────────────────────┘
```

### 4.3 不同 Principal 的 Trust Policy

```
场景1：允许 AWS 服务假扮（EC2、Lambda 等）
───────────────────────────────────────────
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "Service": "ec2.amazonaws.com"
      },
      "Action": "sts:AssumeRole"
    }
  ]
}

// EC2 实例可以自动获取这个 Role 的权限


场景2：允许特定 IAM User 假扮
───────────────────────────────────────────
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "AWS": "arn:aws:iam::123456789012:user/alice"
      },
      "Action": "sts:AssumeRole"
    }
  ]
}

// Alice 可以 assume 这个 Role


场景3：允许另一个账号假扮（跨账号）
───────────────────────────────────────────
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "AWS": "arn:aws:iam::999888777666:root"
      },
      "Action": "sts:AssumeRole"
    }
  ]
}

// 账号 999888777666 中的身份可以 assume 这个 Role


场景4：允许外部身份提供者（OIDC Federation）
───────────────────────────────────────────
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "Federated": "arn:aws:iam::123456789012:oidc-provider/token.actions.githubusercontent.com"
      },
      "Action": "sts:AssumeRoleWithWebIdentity",
      "Condition": {
        "StringEquals": {
          "token.actions.githubusercontent.com:aud": "sts.amazonaws.com"
        },
        "StringLike": {
          "token.actions.githubusercontent.com:sub": "repo:myorg/myrepo:*"
        }
      }
    }
  ]
}

// GitHub Actions 可以用 OIDC Token 换取这个 Role 的权限
```

---

## 5. 工作负载身份的最佳实践

### 5.1 EC2: Instance Profile

```
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  EC2 Instance                                          │
│  ┌───────────────────────────────────────────────────┐ │
│  │                                                   │ │
│  │   应用程序                                        │ │
│  │      │                                            │ │
│  │      │ 调用 AWS SDK                               │ │
│  │      ▼                                            │ │
│  │   SDK 自动从 IMDS 获取凭证                        │ │
│  │      │                                            │ │
│  │      ▼                                            │ │
│  │   http://169.254.169.254/latest/meta-data/       │ │
│  │     iam/security-credentials/MyRole              │ │
│  │                                                   │ │
│  └───────────────────────────────────────────────────┘ │
│                        │                               │
│                        ▼                               │
│  Instance Profile ──► IAM Role ──► 临时凭证           │
│                                                         │
└─────────────────────────────────────────────────────────┘

代码里不需要任何凭证配置：

import boto3
s3 = boto3.client('s3')  # SDK 自动获取凭证
s3.get_object(Bucket='my-bucket', Key='file.txt')
```

### 5.2 Lambda: Execution Role

```
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  Lambda Function                                       │
│  ┌───────────────────────────────────────────────────┐ │
│  │                                                   │ │
│  │   def handler(event, context):                   │ │
│  │       s3 = boto3.client('s3')  # 凭证自动注入    │ │
│  │       ...                                         │ │
│  │                                                   │ │
│  └───────────────────────────────────────────────────┘ │
│                        │                               │
│                        ▼                               │
│  Execution Role ──► 临时凭证通过环境变量注入           │
│                                                         │
│  AWS_ACCESS_KEY_ID=ASIA...                            │
│  AWS_SECRET_ACCESS_KEY=...                            │
│  AWS_SESSION_TOKEN=...                                │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 5.3 EKS: IAM Roles for Service Accounts (IRSA)

```
┌─────────────────────────────────────────────────────────┐
│                     EKS Cluster                         │
│                                                         │
│  ┌─────────────────┐    ┌─────────────────────────────┐│
│  │      Pod        │    │   K8s Service Account       ││
│  │                 │◄───│                             ││
│  │  应用程序        │    │   annotations:              ││
│  │                 │    │     eks.amazonaws.com/      ││
│  └─────────────────┘    │       role-arn: arn:aws:   ││
│          │              │         iam::123:role/MyRole ││
│          │              └─────────────────────────────┘│
│          ▼                                              │
│  AWS_WEB_IDENTITY_TOKEN_FILE=/var/run/secrets/...     │
│  AWS_ROLE_ARN=arn:aws:iam::123:role/MyRole            │
│                                                         │
└─────────────────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────┐
│  SDK 自动使用 OIDC Token 调用 AssumeRoleWithWebIdentity │
│  获取临时凭证                                           │
└─────────────────────────────────────────────────────────┘

Pod 内的应用无需任何凭证配置：
- K8s 自动注入 Token
- AWS SDK 自动识别并使用 IRSA
```

### 5.4 GitHub Actions: OIDC

```
┌─────────────────────────────────────────────────────────┐
│                   GitHub Actions                        │
│                                                         │
│  jobs:                                                 │
│    deploy:                                             │
│      permissions:                                      │
│        id-token: write    # 请求 OIDC Token           │
│        contents: read                                  │
│                                                         │
│      steps:                                            │
│        - uses: aws-actions/configure-aws-credentials  │
│          with:                                         │
│            role-to-assume: arn:aws:iam::123:role/...  │
│            aws-region: us-east-1                      │
│                                                         │
│        - run: aws s3 ls   # 使用临时凭证               │
│                                                         │
└─────────────────────────────────────────────────────────┘

流程：
1. GitHub 签发 OIDC Token（包含 repo、branch 等信息）
2. Action 用 Token 调用 AWS STS AssumeRoleWithWebIdentity
3. AWS 验证 Token 来自可信的 GitHub
4. AWS 返回临时凭证
5. Action 使用临时凭证访问 AWS

优势：不需要在 GitHub 中存储任何 AWS 密钥！
```

---

## 6. 凭证安全清单

### 6.1 该做的 (DO)

```
✅ 人类用户使用 SSO/Federation，避免创建 IAM User
✅ 机器身份使用 IAM Role + 临时凭证
✅ 启用 CloudTrail 监控所有 API 调用
✅ 使用 Access Analyzer 发现未使用的凭证
✅ 定期审查和轮换长期凭证
✅ 为敏感操作强制 MFA
✅ 使用 Secret Manager 管理必须存储的密钥
```

### 6.2 不该做的 (DON'T)

```
❌ 在代码中硬编码 Access Key
❌ 在 Git 仓库中提交凭证
❌ 多个应用共享同一个 Access Key
❌ 创建比需要更多权限的凭证
❌ 长期不轮换凭证
❌ 忽略 Access Key 的使用时间和来源
❌ 使用 Root 账号的 Access Key
```

---

## 7. 总结

```
┌─────────────────────────────────────────────────────────┐
│                   身份与凭证核心概念                     │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  身份类型：                                             │
│    人类用户 ─ 控制台登录，需要 MFA                      │
│    机器身份 ─ API 调用，使用 Role                       │
│                                                         │
│  凭证类型：                                             │
│    长期凭证 ─ 密码、Access Key，有泄露风险              │
│    临时凭证 ─ STS Token，自动过期，更安全               │
│                                                         │
│  最佳实践：                                             │
│    IAM User ─ 仅用于必须的人类用户                      │
│    IAM Role ─ 一切机器身份的首选                        │
│                                                         │
│  工作负载身份：                                         │
│    EC2 ─ Instance Profile                              │
│    Lambda ─ Execution Role                             │
│    EKS ─ IRSA                                          │
│    CI/CD ─ OIDC Federation                             │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

> **核心洞见：现代云架构中，"无密钥"才是最安全的。通过 IAM Role 和工作负载身份，让凭证在运行时动态获取、自动过期，而不是存储在某处等待被泄露。**

---

## 思考题

1. 为什么说 Access Key 的开头是 `AKIA` 还是 `ASIA` 很重要？
2. 如果一个 EC2 实例被入侵，使用 Instance Profile 比使用 Access Key 有什么安全优势？
3. 设计一个方案：让开发者能够临时访问生产环境，但需要 MFA 且有时间限制。
