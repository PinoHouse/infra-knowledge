# IAM 学习路线图：从第一性原理出发

## 核心问题

在任何系统中，访问控制归根结底只需要回答两个问题：

1. **你是谁？** (Authentication - 认证)
2. **你能做什么？** (Authorization - 授权)

IAM (Identity and Access Management) 就是云时代对这两个问题的系统性回答。

---

## 文档索引

| Layer | 文档 | 主题 |
|-------|------|------|
| 1 | [01-why-iam.md](./01-why-iam.md) | 为什么需要 IAM |
| 2 | [02-core-model.md](./02-core-model.md) | IAM 核心模型 |
| 3 | [03-identity-and-credentials.md](./03-identity-and-credentials.md) | 身份与凭证 |
| 4 | [04-assume-role.md](./04-assume-role.md) | Assume Role 机制 |
| 5 | [05-federated-identity.md](./05-federated-identity.md) | 联邦身份 |
| 6 | [06-best-practices.md](./06-best-practices.md) | 最佳实践 |

---

## Layer 1: Why - 为什么需要 IAM

### 权限管理的演进

```
单机时代          网络时代           云时代
   │                 │                 │
   ▼                 ▼                 ▼
本地用户+文件权限   多系统+LDAP      海量资源+服务+身份
(rwx, uid/gid)     (统一目录)        (需要新的抽象)
```

### 云时代的核心挑战

| 挑战 | 说明 |
|------|------|
| **规模爆炸** | 数千个资源、数百个服务、频繁变动的人员 |
| **边界消失** | 没有传统的网络边界，任何地方都可能发起请求 |
| **机器身份** | 不只是人需要权限，服务/应用/CI流水线都需要 |
| **跨组织协作** | 跨账号、跨云、与第三方系统集成 |

### 要解决的根本问题

- 人员入职/离职时权限如何快速调整？
- 如何确保每个主体只有必要的最小权限？
- 出了安全事件如何追溯是谁做的？
- 服务A如何安全地访问服务B的资源？

---

## Layer 2: What - IAM 的核心模型

### 策略的本质

所有云厂商的 IAM 策略，本质上都是回答同一个问题：

```
谁 (Principal)
  在什么条件下 (Condition)
    对什么资源 (Resource)
      能执行什么操作 (Action)？
```

这就是为什么 AWS/GCP/Azure 的策略结构如此相似：

```json
{
  "Principal": "谁",
  "Action": "什么操作",
  "Resource": "什么资源",
  "Effect": "允许/拒绝",
  "Condition": "什么条件"
}
```

### 两种策略类型

```
┌─────────────────────────────────────────────────────┐
│                    访问请求                          │
└─────────────────────────────────────────────────────┘
                         │
                         ▼
         ┌───────────────────────────────┐
         │  Identity-based Policy        │
         │  (附加在主体上：我能做什么)     │
         └───────────────────────────────┘
                         │
                         ▼
         ┌───────────────────────────────┐
         │  Resource-based Policy        │
         │  (附加在资源上：谁能访问我)     │
         └───────────────────────────────┘
                         │
                         ▼
                   Allow / Deny
```

### 策略评估逻辑

```
默认拒绝 (Implicit Deny)
    │
    ▼
有显式拒绝？ ──Yes──► 拒绝
    │
    No
    ▼
有显式允许？ ──No───► 拒绝
    │
    Yes
    ▼
   允许
```

**记住：Deny 永远优先于 Allow**

---

## Layer 3: 身份类型与凭证

### 两类主体

| 类型 | 说明 | 示例 |
|------|------|------|
| **人类用户** | 通过控制台/CLI操作 | 开发者、管理员 |
| **机器身份** | 程序化访问 | EC2实例、Lambda、K8s Pod、CI/CD |

### 凭证的演进

```
静态凭证                    临时凭证
(Long-term)                (Short-term)
    │                          │
    ▼                          ▼
用户名/密码              STS Token
Access Key/Secret        (自动过期)
    │                          │
    ▼                          ▼
  问题：                     优势：
- 泄露风险高               - 有过期时间
- 难以轮换                 - 可追踪来源
- 难以追踪                 - 按需获取
```

### 为什么临时凭证更安全？

1. **时效性**：即使泄露，很快过期
2. **可追溯**：知道是谁、什么时候、为什么获取
3. **最小权限**：可以为特定任务申请特定权限
4. **无需存储**：不用在代码/配置中硬编码长期密钥

---

## Layer 4: Assume Role - 身份切换机制

### 核心问题

**如何让一个身份安全地"借用"另一个身份的权限？**

### 应用场景

- 跨账号访问（账号A的用户访问账号B的资源）
- 服务间调用（Service A 调用 Service B）
- 临时提权（普通操作 vs 敏感操作）
- 外部系统集成（GitHub Actions 部署到 AWS）

### Assume Role 的本质

```
┌──────────────┐         ┌──────────────┐
│   身份 A     │         │   角色 B      │
│  (请求者)    │         │  (被假扮)     │
└──────────────┘         └──────────────┘
       │                        │
       │  1. 我是A,想成为B       │
       │───────────────────────►│
       │                        │
       │         2. 检查信任策略
       │         B 允许 A 假扮吗？
       │                        │
       │  3. 返回临时凭证        │
       │◄───────────────────────│
       │   (AccessKey,          │
       │    SecretKey,          │
       │    SessionToken,       │
       │    Expiration)         │
       │                        │
       ▼
  4. 用临时凭证以B的身份操作
```

### 三层权限控制

```
┌─────────────────────────────────────────┐
│  Trust Policy (信任策略)                 │
│  谁可以 assume 这个角色？                │
└─────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────┐
│  Permission Policy (权限策略)            │
│  这个角色能做什么？                      │
└─────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────┐
│  Session Policy (会话策略) [可选]        │
│  本次会话进一步限制什么？                │
└─────────────────────────────────────────┘
```

**最终权限 = 三者的交集**

---

## Layer 5: 联邦身份 - 跨边界的信任

### 核心问题

**如何让外部身份系统的用户访问云资源，而不用在云上再创建一套用户？**

### 联邦身份的本质

```
┌─────────────┐      ┌─────────────┐      ┌─────────────┐
│ 外部 IdP    │      │  云平台     │      │   资源      │
│ (身份提供者) │      │  (信任方)   │      │            │
└─────────────┘      └─────────────┘      └─────────────┘
       │                    │                    │
       │  1. 用户登录IdP    │                    │
       │◄──────────────────                      │
       │                    │                    │
       │  2. IdP签发Token   │                    │
       │────────────────────►                    │
       │  (OIDC/SAML断言)   │                    │
       │                    │                    │
       │         3. 云平台验证Token              │
       │            映射到云角色                 │
       │                    │                    │
       │                    │  4. 访问资源       │
       │                    │───────────────────►│
```

### 常见联邦身份场景

| 场景 | IdP | 说明 |
|------|-----|------|
| 企业SSO | Okta/Azure AD | 员工用企业账号登录云平台 |
| GitHub Actions | GitHub OIDC | CI/CD 无需存储云密钥 |
| K8s Workload | K8s OIDC | Pod 自动获取云权限 |

### OIDC 的关键概念

- **Issuer**: 谁签发的 Token（要被信任）
- **Audience**: Token 给谁用的
- **Subject**: Token 代表谁
- **Claims**: Token 中的属性信息

---

## Layer 6: 工作负载身份 - 机器的身份证

### 核心问题

**运行在云上的应用如何安全地获取访问其他云资源的权限？**

### 演进路径

```
硬编码密钥          环境变量/配置        工作负载身份
(代码里写死)        (稍微好点)          (最佳实践)
    │                  │                   │
    ▼                  ▼                   ▼
  问题：             问题：              优势：
- 泄露到Git        - 仍需管理密钥       - 无需管理密钥
- 无法轮换         - 泄露风险           - 自动轮换
- 谁都能用         - 难以最小权限       - 绑定到特定负载
```

### 各云厂商实现

| 云厂商 | 机制 | 说明 |
|--------|------|------|
| AWS | Instance Profile / IAM Roles for Service Accounts | EC2/EKS 自动获取角色 |
| GCP | Service Account + Workload Identity | GCE/GKE 自动获取身份 |
| Azure | Managed Identity | VM/AKS 自动获取身份 |

### K8s 与云 IAM 的集成

```
┌─────────────────────────────────────────────────────┐
│                    K8s Cluster                       │
│  ┌─────────────┐      ┌─────────────────────────┐   │
│  │    Pod      │      │  K8s Service Account    │   │
│  │             │◄────►│  (集群内身份)            │   │
│  └─────────────┘      └─────────────────────────┘   │
│                                │                     │
│                                │ OIDC Federation     │
│                                ▼                     │
└─────────────────────────────────────────────────────┘
                                 │
                                 ▼
                    ┌─────────────────────────┐
                    │  Cloud IAM Role         │
                    │  (云平台权限)            │
                    └─────────────────────────┘
```

---

## Layer 7: 最佳实践原则

### 最小权限原则 (Least Privilege)

> 只授予完成工作所需的最小权限，不多一分

**实践方法**：
- 从零权限开始，按需添加
- 使用 Access Analyzer 发现过度权限
- 定期审查和收缩权限

### 零信任原则 (Zero Trust)

> 永不信任，始终验证

**核心思想**：
- 不因为在"内网"就信任
- 每次访问都要验证身份
- 持续评估风险

### 职责分离 (Separation of Duties)

> 敏感操作需要多人/多角色配合

**示例**：
- 开发者不能直接访问生产数据库
- 部署需要审批流程
- 密钥管理与使用分离

---

## 学习检查清单

### 概念理解
- [ ] 能解释认证(AuthN)和授权(AuthZ)的区别
- [ ] 能画出策略评估的流程图
- [ ] 理解为什么临时凭证比长期凭证安全

### Assume Role
- [ ] 能解释 Trust Policy 和 Permission Policy 的作用
- [ ] 能设计跨账号访问的角色配置
- [ ] 理解 Session Policy 的使用场景

### 联邦身份
- [ ] 能解释 OIDC 的基本流程
- [ ] 理解 GitHub Actions → AWS 的 OIDC 集成原理
- [ ] 能配置 K8s ServiceAccount 到云 IAM 的映射

### 实践能力
- [ ] 能为一个应用设计最小权限策略
- [ ] 能排查权限拒绝的问题
- [ ] 能设计多账号的权限架构

---

## 推荐学习顺序

```
1. 理解 Why (本文 Layer 1)
        │
        ▼
2. 掌握核心模型 (Layer 2: Principal/Action/Resource/Condition)
        │
        ▼
3. 实践单账号 IAM (创建用户、角色、策略)
        │
        ▼
4. 深入 Assume Role (Layer 4: 跨账号、服务间调用)
        │
        ▼
5. 理解联邦身份 (Layer 5-6: OIDC, Workload Identity)
        │
        ▼
6. 综合实践 (设计完整的多账号权限架构)
```
