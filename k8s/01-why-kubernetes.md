# 第一层：理解"为什么" (Why) - 深度展开

## 1. 从第一性原理看容器化演进

### 1.1 应用部署的本质挑战

```
核心问题：如何让代码在任何地方可靠运行？

传统痛点：
┌─────────────────────────────────────────────────────┐
│  "在我机器上能跑啊！"                                │
│                                                     │
│  开发环境 ──────────✗────────── 生产环境            │
│  (Python 3.8)                   (Python 3.6)       │
│  (libssl 1.1)                   (libssl 1.0)       │
│  (Ubuntu 20.04)                 (CentOS 7)         │
└─────────────────────────────────────────────────────┘
```

### 1.2 Docker 解决了什么

```
Docker 的本质：把应用和它的依赖打包成一个标准化的"集装箱"

┌──────────────────────────────────────────┐
│            Container Image               │
│  ┌─────────────────────────────────────┐ │
│  │  App Binary                         │ │
│  │  + Libraries                        │ │
│  │  + Config                           │ │
│  │  + Runtime                          │ │
│  └─────────────────────────────────────┘ │
│  = 完整的、自包含的运行单元              │
└──────────────────────────────────────────┘

技术手段：
  - Namespace  → 进程隔离（PID、网络、文件系统）
  - Cgroups    → 资源限制（CPU、内存）
  - UnionFS    → 分层镜像、写时复制
```

**Docker 解决的问题：**
- 环境一致性（Build once, run anywhere）
- 进程隔离
- 快速启动
- 资源效率（比 VM 更轻量）

### 1.3 Docker 解决不了的问题

当你只有一台机器时，Docker 够用了。但现实中：

```
单机 Docker 的局限：

问题1：容器挂了怎么办？
  Container ──────✗────── 谁来重启？

问题2：流量增大怎么办？
  用户 ─→ Container    ← 一个扛不住，怎么扩？

问题3：多台机器怎么协调？
  ┌─────────┐  ┌─────────┐  ┌─────────┐
  │ Host A  │  │ Host B  │  │ Host C  │
  │ ???     │  │ ???     │  │ ???     │
  └─────────┘  └─────────┘  └─────────┘
  容器放哪台？互相怎么通信？

问题4：服务发现怎么做？
  Frontend ──→ Backend ???
               IP 会变，怎么找？

问题5：滚动更新怎么做？
  v1 → v2  不停机怎么升级？
```

### 1.4 K8s 的定位

```
Kubernetes = 分布式容器编排系统

           单机问题          分布式问题
              │                  │
    Docker ◀──┘                  └──▶ Kubernetes
    (容器运行时)                      (容器编排)
```

K8s 解决的核心问题：

| 问题 | 描述 |
|------|------|
| 调度 | 容器应该运行在哪台机器？ |
| 编排 | 多个容器如何协同工作？ |
| 自愈 | 容器挂了自动重启/迁移 |
| 扩缩容 | 根据负载自动增减副本 |
| 服务发现 | 容器之间如何互相找到对方？ |
| 负载均衡 | 流量如何分发到多个副本？ |
| 滚动更新 | 如何零停机升级？ |
| 配置管理 | 如何管理应用配置和密钥？ |

---

## 2. K8s 的核心设计哲学

### 2.1 声明式 vs 命令式

这是理解 K8s 最关键的概念：

```
命令式 (Imperative)：告诉系统"怎么做"
─────────────────────────────────────────
  1. 启动容器 A
  2. 启动容器 B
  3. 如果 A 挂了，重启 A
  4. 如果流量大了，再启动一个 A
  ...

  问题：你需要预见所有情况，写无数 if-else


声明式 (Declarative)：告诉系统"我要什么"
─────────────────────────────────────────
  我要：
    - 3 个 nginx 副本
    - 每个 512MB 内存
    - 对外暴露 80 端口

  至于怎么实现？系统自己搞定。
```

**真实类比：**
```
命令式 = 自己开车
  左转、直行、右转、减速、加速...

声明式 = 叫出租车
  "我要去机场"
  司机自己决定怎么走
```

### 2.2 期望状态 vs 实际状态

```
┌───────────────────────────────────────────────────────┐
│                                                       │
│   Desired State          Current State               │
│   (你想要的)              (现实情况)                  │
│                                                       │
│   replicas: 3      vs    running pods: 2             │
│                                                       │
│              ↓                                        │
│                                                       │
│         K8s 发现差异，自动创建 1 个新 Pod             │
│                                                       │
└───────────────────────────────────────────────────────┘

你只需要定义期望状态，K8s 负责让现实向期望靠拢。
```

### 2.3 控制循环 (Control Loop) - K8s 的心跳

这是 K8s 所有魔法的核心：

```
      ┌─────────────────────────────────────┐
      │                                     │
      ▼                                     │
┌──────────┐    ┌──────────┐    ┌──────────┴┐
│ Observe  │ ──▶│   Diff   │ ──▶│   Act     │
│ 观察现状  │    │ 对比差异  │    │  执行动作  │
└──────────┘    └──────────┘    └───────────┘
```

无限循环，永不停止：

```python
while true:
    current = get_current_state()
    desired = get_desired_state()    # 来自 etcd

    if current != desired:
        reconcile(current, desired)  # 调和

    sleep(interval)
```

**真实例子：**

```yaml
# 你声明的期望状态
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx
spec:
  replicas: 3        # ← 我要 3 个副本
```

```
时间线：
───────────────────────────────────────────────────────
t0: 你 apply 这个 YAML
t1: Controller 看到期望 3 副本，实际 0 副本 → 创建 3 个 Pod
t2: 运行正常，3/3
t3: 某个 Pod 挂了，实际变成 2 副本
t4: Controller 发现 2 ≠ 3 → 创建 1 个新 Pod
t5: 恢复正常，3/3
...
(永远循环)
```

### 2.4 为什么声明式 + 控制循环如此强大？

**1. 自愈能力**
```
你不用写 "if pod dies then restart"
控制循环自动处理
```

**2. 幂等性**
```
apply 同一个 YAML 100 次，结果都一样
不用担心重复执行带来副作用
```

**3. 最终一致性**
```
即使中间出错，系统会不断重试直到达成期望状态
```

**4. 可预测性**
```
YAML 就是唯一的真相来源
看 YAML 就知道系统应该是什么样
```

---

## 3. 总结：第一性原理的三个层次

```
Layer 0: 为什么需要容器？
         → 解决环境一致性问题

Layer 1: 为什么需要编排？
         → 解决分布式环境下的调度、扩缩容、自愈问题

Layer 2: 为什么选择声明式？
         → 用户只关心"是什么"，系统负责"怎么做"
         → 控制循环让系统具备自愈能力
```

> **核心洞见：K8s 不是让你管理容器，而是让你描述意图，然后它替你管理容器。**
